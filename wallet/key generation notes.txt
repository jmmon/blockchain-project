BIP 44:

Understanding derivation path levels:
5 levels in BIP32 path:
	m / purpose' / coin_type' / account' / change / address_index
Apostrophe indicates that BIP32-hardened-derivation is used

"Purpose":
A constant, set to 44' (or 0x8000002C) (following BIP43 recommendation). It indicates the subtree of this node is used according to the specification!
Hardened derivation is used at this level.

"Coin type":
One master node (seed) can be used for unlimited number of independent cryptocurrencies! However, sharing the same space has disadvantages.
This path level creates a separate subtree for each cryptocurrency, avoiding reusing addresses across coins (and improving privacy issues).
This is a constant, set for each cryptocurrency. (Developers may ask to register an unused number for their project - see registered coin types)
Hardened derivation is used at this level.

"Account":
This derivation path level splits the "key space" into independent "user identities", so wallet never mixes coins across different accounts.
Users can use these accounts to organize funds like bank accounts; for donation purposes; saving purposes; common expenses; etc
Accounts are numbered from 0 and increasing sequentially. This number (index) is used as "child index" in BIP32 derivation
Software should prevent creation of account if previous account does not have a transaction history (none of the addresses have been used before).
Software needs to discover all used accounts after importing a seed. (See below)
Hardened derivation is used at this level.

"Change":
Constant: 0 is used for external chain (public receiving addresses) while 1 is used for internal chain (change addresses; only receiving coins from the "external chain" addresses).
"Public derivation" is used at this level.

"Index":
Addresses are numbered from 0, sequentially increasing. This is used as "child index" in BIP32 derivation.
"Public derivation" is used at this level.


Account Discovery Algorithm:
When master seed is imported, wallet should start to discover accounts in following manner:

1. Derive first account's node (index 0)
2. derive external chain node of this account (addresses intended to be publicly viewable?)
3. scan addresses of external chain; respect gap limit (described below?)
4. If no transactions found on external chain, stop discovery
5. If some transactions, increment account index and go back to step 1

This works because wallets should disallow creation of new accounts if previous one has no transaction history

Note that it works with transaction history, not account balances, so will continue discovery if account has 0 total coins

Gap limit: 20
If software hits 20 unused addresses in a row, it stops searching that "address chain" because it assumes no used addresses will be found.
We only scan "external" chains, because internal chains receive coins only from the external chain anyway.
Wallet should warn user when they try to generate a new address which would exceed the gap limit!













Notes on deriving keys:






Notes on Private Key Formats:
"unlock satoshis from a particular address."
"Wallet Import Format" uses base58Check encoding on private key, greatly decreasing chance of copying error (much like standard Bitcoin addresses)
>> Take private key
>> Create extended key by adding 0x80 byte in front (for testnet use 0xef byte)
>> If should be used with compressed public keys, append 0x01 byte after (else do not append anything)
>> Perform SHA-256 hash on extended key (extended private key?)
>> Perform SHA-256 hash on result of previous SHA-256 hash
>> take first four bytes of second hash as the "checksum"
>> add "checksum" to end of extended key (from second step)
>> Convert to Base58 string using "Base58Check" encoding

>> Easily reversible using decoding function and removing padding



Mini Private Key format for encoding private key in under 30 characters:
>> First char of key is "S"
>> To determine if mini-private-key is "well-formatted", append a "?"
>> Calc SHA-256 hash:
	>> If first byte == "00": it is "well-formatted"; acts as typo-checking mechanism
	>> else, we try again until we get a "well-formatted" key!!
>> To derive full private key, simply take single SHA-256 hash of mini-private-key! (This process is one-way; "intractable" to compute mini-private-key from derived key)



ECDSA curve, Public Key Formats:
Every x coordinate has two y coordinates: so all we need to know from the y coordinate is if it is positive or negative. This reduces size of our private key by almost half! This creates a "compressed public key"
Because of change from uncompressed to compressed, bitcoin has identifiers:
	Priv keys with compressed pub keys have 0x01 appended before base-58 encoding
	uncompressed pub keys start with 0x04;
	compressed pub keys start with 0x02 or 0x03 (negative or positive y coordinate)




HD Key Creation:
Because of how "point()" works, it's possible to create a "child public key" from existing "parent public key" + "another public key (created from any integer)". 
This key is same as if created by "point()" function by adding integer value to original (parent) private key, and then found remainder of that sum divided by "Bitcoin global constant P"; meaning:
	>> two programs can create a series of unique child key pairs from a single parent key so long as they agree on a sequence of integers.
	>> a program distributing new receiving keys (public keys) can do so WITHOUT access to the private key!

Child keys can also create their own "child public keys" ("grandchild public keys") using the same method on the child private/public keys

If integer sequence is predictable, anyone knowing one "child public key" could find all other "child public keys" generate from same "parent public key", so instead we can use a "random seed" to deterministically generate integer values, to hide relationship between the "child public keys"

HD protocol uses a single "root seed" to create hierarchy of child, grandchild, and other descendent keys, unlinkably and deterministically.
	Each child key also gets deterministically-generated seed from its parent, called a "chain code", so compromise of one "chain code" doesn't necessarily compromise integer sequence of whole hierarchy; allowing "master chain code" to continue being useful.

"Parent chain code" + "parent public key" + "index" are hashed (HMAC-SHA512); 
	the right half of the hash is used as a new "child chain code"
	the left half used as the integer value (to be combined with either the "parent private key" or "parent public key" to create a "child private key" or "child public key", respectively)

Because creating child keys requires both a key and a chain code, these together are called an "extended key".
	"Extended private key" and "extended public key" share the same "chain code"
	the "master private key" (top level) and "master chain code" are derived from random data

A "root seed" is created; the only thing needing to be backed up to be able to recover access to all keys derived from it. It's also derived from a mnemonic.

"Master Private Key" and "Master Chain Code" combine to create "Master Extended Private Key"

"Master Public Key" derived from "Master Private Key"
"Master Public Key" with "Master Chain Code" make "Master Extended Public Key"

These "master extended keys" are functionally equivalent to "other extended keys"; the only difference being the location at the TOP of the hierarchy.



Hardened keys:
If attacker gets normal "parent chain code" and "parent public key", they can brute-force all "chain codes" derived from it
If they obtain child, grandchild, or descended "private key", they can use the chain code to generate all "extended private keys" descending from that "private key";
or even reverse "child private key" formula to recover the "parent private key"

Hardened keys require "parent chain code", "parent private key", and "index" to generate "child chain code" and "child private key", making it impossible to create "child public keys" without knowing "parent private key";
meaning: "parent extended public keys" cannot create "hardened child public keys"




Bip32:
Wallets following Bip32 ONLY create "hardened children" of the "master private key (m)";
meaning: no "normal children" for the "master keys", and so "master public key" is NOT used in HD wallets.
All other keys can have normal children (so corresponding "extended public keys" may be used instead)



Passwords:
Can be added to mnemonic
Any password generates a valid seed, so no way to prove which password is "correct" when under duress



(Alternately, old style was generate a "key pool", but these are hard to back up and so are deprecated.)